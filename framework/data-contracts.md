# Data Contracts - Options Trading Backtest Engine

## Overview

This document defines the data contracts and schemas used throughout the Options Trading Backtest Engine. All data structures are designed to be immutable, type-safe, and serializable across Python and TypeScript boundaries.

## Core Data Types

### 1. Market Data Contracts

#### OHLCV Data Structure
```python
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import Optional

@dataclass(frozen=True)
class OHLCVBar:
    """Immutable OHLCV bar data"""
    symbol: str
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int
    adjusted_close: Optional[Decimal] = None
    
    def __post_init__(self):
        # Validation logic
        assert self.high >= max(self.open, self.close)
        assert self.low <= min(self.open, self.close)
        assert self.volume >= 0
```

#### Options Chain Data
```python
@dataclass(frozen=True)
class OptionContract:
    """Individual option contract data"""
    symbol: str
    underlying: str
    expiration: datetime
    strike: Decimal
    option_type: str  # 'call' or 'put'
    bid: Optional[Decimal]
    ask: Optional[Decimal]
    last: Optional[Decimal]
    volume: int
    open_interest: int
    implied_volatility: Optional[Decimal]
    delta: Optional[Decimal]
    gamma: Optional[Decimal]
    theta: Optional[Decimal]
    vega: Optional[Decimal]
    rho: Optional[Decimal]
    
    @property
    def mid_price(self) -> Optional[Decimal]:
        if self.bid and self.ask:
            return (self.bid + self.ask) / 2
        return self.last

@dataclass(frozen=True)
class OptionsChain:
    """Complete options chain for an underlying"""
    underlying: str
    timestamp: datetime
    underlying_price: Decimal
    contracts: list[OptionContract]
    
    def get_calls(self) -> list[OptionContract]:
        return [c for c in self.contracts if c.option_type == 'call']
    
    def get_puts(self) -> list[OptionContract]:
        return [c for c in self.contracts if c.option_type == 'put']
    
    def get_expiration_dates(self) -> list[datetime]:
        return sorted(set(c.expiration for c in self.contracts))
```

### 2. Position and Portfolio Contracts

#### Position Data
```python
@dataclass(frozen=True)
class Position:
    """Individual position in portfolio"""
    symbol: str
    quantity: Decimal  # Positive for long, negative for short
    average_price: Decimal
    current_price: Optional[Decimal]
    market_value: Optional[Decimal]
    unrealized_pnl: Optional[Decimal]
    realized_pnl: Decimal
    opened_at: datetime
    last_updated: datetime
    
    @property
    def is_long(self) -> bool:
        return self.quantity > 0
    
    @property
    def is_short(self) -> bool:
        return self.quantity < 0
    
    @property
    def notional_value(self) -> Decimal:
        return abs(self.quantity * self.average_price)

@dataclass(frozen=True)
class Portfolio:
    """Complete portfolio state"""
    account_id: str
    timestamp: datetime
    cash: Decimal
    positions: dict[str, Position]
    total_value: Decimal
    unrealized_pnl: Decimal
    realized_pnl: Decimal
    
    @property
    def position_value(self) -> Decimal:
        return sum(p.market_value or Decimal(0) for p in self.positions.values())
    
    @property
    def total_pnl(self) -> Decimal:
        return self.unrealized_pnl + self.realized_pnl
```

### 3. Strategy and Signal Contracts

#### Signal Data
```python
from enum import Enum

class SignalType(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"

class SignalStrength(Enum):
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"

@dataclass(frozen=True)
class Signal:
    """Trading signal generated by strategy"""
    signal_id: str
    strategy_id: str
    symbol: str
    signal_type: SignalType
    strength: SignalStrength
    confidence: Decimal  # 0.0 to 1.0
    timestamp: datetime
    price: Optional[Decimal]
    quantity: Optional[Decimal]
    metadata: dict[str, any]
    
    def __post_init__(self):
        assert 0 <= self.confidence <= 1
```

#### Strategy Performance
```python
@dataclass(frozen=True)
class StrategyPerformance:
    """Strategy performance metrics"""
    strategy_id: str
    start_date: datetime
    end_date: datetime
    total_return: Decimal
    annualized_return: Decimal
    volatility: Decimal
    sharpe_ratio: Decimal
    max_drawdown: Decimal
    win_rate: Decimal
    profit_factor: Decimal
    total_trades: int
    winning_trades: int
    losing_trades: int
    average_win: Decimal
    average_loss: Decimal
    largest_win: Decimal
    largest_loss: Decimal
```

### 4. Risk Management Contracts

#### Risk Metrics
```python
@dataclass(frozen=True)
class RiskMetrics:
    """Portfolio risk assessment"""
    portfolio_id: str
    timestamp: datetime
    total_exposure: Decimal
    net_exposure: Decimal
    gross_exposure: Decimal
    leverage: Decimal
    var_95: Decimal  # Value at Risk 95%
    var_99: Decimal  # Value at Risk 99%
    expected_shortfall: Decimal
    beta: Decimal
    correlation_to_market: Decimal
    sector_exposures: dict[str, Decimal]
    
    def __post_init__(self):
        assert self.leverage >= 0
        assert -1 <= self.correlation_to_market <= 1
```

#### Position Sizing
```python
@dataclass(frozen=True)
class PositionSizeRequest:
    """Request for position sizing calculation"""
    strategy_id: str
    symbol: str
    signal: Signal
    current_portfolio: Portfolio
    risk_parameters: dict[str, any]

@dataclass(frozen=True)
class PositionSizeResponse:
    """Response from position sizing calculation"""
    request_id: str
    recommended_quantity: Decimal
    max_quantity: Decimal
    risk_adjusted_quantity: Decimal
    expected_risk: Decimal
    reasoning: str
    warnings: list[str]
```

## TypeScript Data Contracts

### 1. Frontend State Types

#### Position State
```typescript
// app/state/position.ts types
export interface Position {
  readonly symbol: string;
  readonly quantity: number;
  readonly averagePrice: number;
  readonly currentPrice?: number;
  readonly marketValue?: number;
  readonly unrealizedPnl?: number;
  readonly realizedPnl: number;
  readonly openedAt: string; // MM/DD/YYYY format
  readonly lastUpdated: string; // MM/DD/YYYY format
}

export interface Portfolio {
  readonly accountId: string;
  readonly timestamp: string; // MM/DD/YYYY format
  readonly cash: number;
  readonly positions: Record<string, Position>;
  readonly totalValue: number;
  readonly unrealizedPnl: number;
  readonly realizedPnl: number;
}
```

#### Chart Data Types
```typescript
// app/components/PayoffChart.props.ts
export interface PayoffChartData {
  readonly underlyingPrice: number;
  readonly payoff: number;
  readonly probability?: number;
}

export interface PayoffChartProps {
  readonly data: PayoffChartData[];
  readonly currentPrice: number;
  readonly title?: string;
  readonly width?: number;
  readonly height?: number;
  readonly showProbability?: boolean;
  readonly onPointHover?: (point: PayoffChartData) => void;
  readonly onPointClick?: (point: PayoffChartData) => void;
}
```

### 2. API Response Types

#### Market Data API
```typescript
export interface OHLCVResponse {
  readonly symbol: string;
  readonly data: Array<{
    readonly timestamp: string;
    readonly open: number;
    readonly high: number;
    readonly low: number;
    readonly close: number;
    readonly volume: number;
    readonly adjustedClose?: number;
  }>;
}

export interface OptionsChainResponse {
  readonly underlying: string;
  readonly timestamp: string;
  readonly underlyingPrice: number;
  readonly contracts: Array<{
    readonly symbol: string;
    readonly expiration: string;
    readonly strike: number;
    readonly optionType: 'call' | 'put';
    readonly bid?: number;
    readonly ask?: number;
    readonly last?: number;
    readonly volume: number;
    readonly openInterest: number;
    readonly impliedVolatility?: number;
    readonly delta?: number;
    readonly gamma?: number;
    readonly theta?: number;
    readonly vega?: number;
    readonly rho?: number;
  }>;
}
```

## Data Validation Rules

### 1. Price Validation
- All prices must be non-negative
- Bid prices must be less than or equal to ask prices
- OHLC relationships must be maintained (H >= max(O,C), L <= min(O,C))

### 2. Quantity Validation
- Quantities can be positive (long) or negative (short)
- Volume must be non-negative integers
- Open interest must be non-negative integers

### 3. Date/Time Validation
- All timestamps must be in UTC
- Expiration dates must be in the future for active contracts
- Date strings in frontend must follow MM/DD/YYYY format

### 4. Options Validation
- Strike prices must be positive
- Implied volatility must be between 0 and 10 (1000%)
- Greeks must be within reasonable ranges
- Option type must be 'call' or 'put'

### 5. Portfolio Validation
- Cash balance can be negative (margin account)
- Total portfolio value must equal cash + position values
- Position quantities must match trade history

## Serialization Standards

### 1. JSON Serialization
- Use ISO 8601 format for timestamps
- Serialize Decimal types as strings to preserve precision
- Include schema version in all serialized objects

### 2. Database Storage
- Store prices as DECIMAL(18,8) for precision
- Use TIMESTAMP WITH TIME ZONE for all datetime fields
- Implement proper indexing for time-series queries

### 3. API Communication
- Use consistent field naming (camelCase for JSON)
- Include request/response correlation IDs
- Implement proper error response schemas

This data contract specification ensures type safety, data integrity, and consistent communication across all components of the Options Trading Backtest Engine.
