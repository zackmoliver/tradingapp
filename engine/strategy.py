"""
Strategy Engine Interfaces - Options Trading Backtest Engine

This module defines the abstract interfaces for trading strategy execution,
portfolio management, and performance tracking. All strategy implementations
must conform to these contracts for consistent behavior and testability.

NO BUSINESS LOGIC - INTERFACES ONLY
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime, date
from decimal import Decimal
from typing import Protocol, Optional, List, Dict, Any, Generic, TypeVar, Union, Callable
from enum import Enum
import uuid

# Import data types from other modules
from ..data.provider import OHLCVBar, OptionContract, OptionsChain


# Core Strategy Data Types
class OrderType(Enum):
    """Order types for strategy execution"""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderSide(Enum):
    """Order side specification"""
    BUY = "buy"
    SELL = "sell"
    BUY_TO_OPEN = "buy_to_open"
    SELL_TO_OPEN = "sell_to_open"
    BUY_TO_CLOSE = "buy_to_close"
    SELL_TO_CLOSE = "sell_to_close"


class OrderStatus(Enum):
    """Order execution status"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class PositionType(Enum):
    """Position types"""
    LONG = "long"
    SHORT = "short"
    LONG_CALL = "long_call"
    SHORT_CALL = "short_call"
    LONG_PUT = "long_put"
    SHORT_PUT = "short_put"


@dataclass(frozen=True)
class Order:
    """Immutable order specification"""
    order_id: str
    strategy_id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: Decimal
    price: Optional[Decimal]
    stop_price: Optional[Decimal]
    time_in_force: str  # 'GTC', 'DAY', 'IOC', 'FOK'
    created_at: datetime
    expires_at: Optional[datetime]
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class Fill:
    """Order fill/execution record"""
    fill_id: str
    order_id: str
    symbol: str
    quantity: Decimal
    price: Decimal
    timestamp: datetime
    commission: Decimal
    fees: Decimal
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class Position:
    """Current position in portfolio"""
    symbol: str
    position_type: PositionType
    quantity: Decimal
    average_price: Decimal
    current_price: Optional[Decimal]
    market_value: Optional[Decimal]
    unrealized_pnl: Optional[Decimal]
    realized_pnl: Decimal
    opened_at: datetime
    last_updated: datetime
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class Portfolio:
    """Complete portfolio state snapshot"""
    portfolio_id: str
    strategy_id: str
    timestamp: datetime
    cash: Decimal
    positions: Dict[str, Position]
    total_value: Decimal
    unrealized_pnl: Decimal
    realized_pnl: Decimal
    margin_used: Decimal
    buying_power: Decimal
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class MarketEvent:
    """Market data event for strategy processing"""
    event_id: str
    timestamp: datetime
    symbol: str
    event_type: str  # 'price_update', 'options_chain', 'volume_spike'
    data: Dict[str, Any]
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class StrategySignal:
    """Signal generated by strategy"""
    signal_id: str
    strategy_id: str
    symbol: str
    signal_type: str  # 'buy', 'sell', 'hold', 'close'
    strength: str  # 'weak', 'moderate', 'strong'
    confidence: Decimal  # 0.0 to 1.0
    timestamp: datetime
    target_price: Optional[Decimal]
    target_quantity: Optional[Decimal]
    reasoning: str
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class StrategyParameters:
    """Strategy configuration parameters"""
    strategy_name: str
    version: str
    parameters: Dict[str, Any]
    risk_parameters: Dict[str, Any]
    universe: List[str]  # Symbols to trade
    benchmark: Optional[str]
    start_date: datetime
    end_date: Optional[datetime]
    initial_capital: Decimal
    metadata: Dict[str, Any]


class StrategyContext(Protocol):
    """
    Context interface providing strategy execution environment.
    
    Provides access to market data, portfolio state, and execution
    capabilities without exposing implementation details.
    """

    @abstractmethod
    def get_current_time(self) -> datetime:
        """
        Get current simulation or live trading time.
        
        Returns:
            Current timestamp in strategy execution context
        """
        ...

    @abstractmethod
    def get_current_price(self, symbol: str) -> Optional[Decimal]:
        """
        Get current price for a symbol.
        
        Args:
            symbol: Symbol to get price for
            
        Returns:
            Current price if available
        """
        ...

    @abstractmethod
    def get_historical_data(
        self,
        symbol: str,
        lookback_periods: int
    ) -> List[OHLCVBar]:
        """
        Get historical OHLCV data for analysis.
        
        Args:
            symbol: Symbol to get data for
            lookback_periods: Number of periods to look back
            
        Returns:
            List of historical OHLCV bars
        """
        ...

    @abstractmethod
    def get_options_chain(self, underlying: str) -> Optional[OptionsChain]:
        """
        Get current options chain for underlying.
        
        Args:
            underlying: Underlying symbol
            
        Returns:
            Current options chain if available
        """
        ...

    @abstractmethod
    def get_portfolio(self) -> Portfolio:
        """
        Get current portfolio state.
        
        Returns:
            Current portfolio snapshot
        """
        ...

    @abstractmethod
    def get_position(self, symbol: str) -> Optional[Position]:
        """
        Get current position for symbol.
        
        Args:
            symbol: Symbol to get position for
            
        Returns:
            Current position if exists
        """
        ...

    @abstractmethod
    def submit_order(self, order: Order) -> str:
        """
        Submit order for execution.
        
        Args:
            order: Order to submit
            
        Returns:
            Order ID for tracking
            
        Raises:
            OrderError: When order submission fails
        """
        ...

    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        Cancel pending order.
        
        Args:
            order_id: Order to cancel
            
        Returns:
            True if cancellation successful
        """
        ...

    @abstractmethod
    def log_event(self, level: str, message: str, metadata: Dict[str, Any]) -> None:
        """
        Log strategy event for debugging/analysis.
        
        Args:
            level: Log level ('debug', 'info', 'warning', 'error')
            message: Log message
            metadata: Additional context data
        """
        ...


class Strategy(Protocol):
    """
    Base strategy interface for trading algorithm implementation.
    
    All trading strategies must implement this protocol to participate
    in the backtesting and live trading framework.
    """

    @abstractmethod
    def initialize(
        self,
        context: StrategyContext,
        parameters: StrategyParameters
    ) -> None:
        """
        Initialize strategy with context and parameters.
        
        Called once at strategy startup to set up initial state,
        validate parameters, and prepare for execution.
        
        Args:
            context: Strategy execution context
            parameters: Strategy configuration parameters
            
        Raises:
            StrategyError: When initialization fails
        """
        ...

    @abstractmethod
    def on_market_data(
        self,
        context: StrategyContext,
        event: MarketEvent
    ) -> List[StrategySignal]:
        """
        Process market data event and generate signals.
        
        Called whenever new market data is available. Strategy should
        analyze the data and return any trading signals generated.
        
        Args:
            context: Strategy execution context
            event: Market data event
            
        Returns:
            List of generated trading signals
            
        Raises:
            StrategyError: When processing fails
        """
        ...

    @abstractmethod
    def on_order_fill(
        self,
        context: StrategyContext,
        fill: Fill
    ) -> List[StrategySignal]:
        """
        Process order fill event.
        
        Called when an order submitted by this strategy is filled.
        Strategy can update internal state and generate new signals.
        
        Args:
            context: Strategy execution context
            fill: Order fill details
            
        Returns:
            List of signals generated in response to fill
            
        Raises:
            StrategyError: When processing fails
        """
        ...

    @abstractmethod
    def on_timer(
        self,
        context: StrategyContext,
        timestamp: datetime
    ) -> List[StrategySignal]:
        """
        Process timer event for periodic strategy logic.
        
        Called at regular intervals to allow strategy to perform
        time-based analysis and signal generation.
        
        Args:
            context: Strategy execution context
            timestamp: Current timestamp
            
        Returns:
            List of generated trading signals
            
        Raises:
            StrategyError: When processing fails
        """
        ...

    @abstractmethod
    def validate_signal(
        self,
        context: StrategyContext,
        signal: StrategySignal
    ) -> bool:
        """
        Validate signal before execution.
        
        Called before converting signals to orders. Strategy can
        perform final validation and risk checks.
        
        Args:
            context: Strategy execution context
            signal: Signal to validate
            
        Returns:
            True if signal is valid for execution
        """
        ...

    @abstractmethod
    def get_strategy_info(self) -> Dict[str, Any]:
        """
        Get strategy metadata and information.
        
        Returns:
            Dictionary with strategy information:
            - name: Strategy name
            - version: Strategy version
            - description: Strategy description
            - parameters_schema: Expected parameters schema
            - risk_parameters_schema: Expected risk parameters schema
        """
        ...

    @abstractmethod
    def cleanup(self, context: StrategyContext) -> None:
        """
        Cleanup strategy resources.
        
        Called when strategy execution is stopping. Strategy should
        clean up any resources and finalize state.
        
        Args:
            context: Strategy execution context
        """
        ...


class PortfolioManager(Protocol):
    """
    Interface for portfolio state management and tracking.
    
    Handles position updates, P&L calculations, and portfolio
    state maintenance across strategy execution.
    """

    @abstractmethod
    def update_position(
        self,
        symbol: str,
        fill: Fill
    ) -> Position:
        """
        Update position based on order fill.
        
        Args:
            symbol: Symbol being updated
            fill: Order fill details
            
        Returns:
            Updated position
            
        Raises:
            PortfolioError: When update fails
        """
        ...

    @abstractmethod
    def calculate_portfolio_value(
        self,
        current_prices: Dict[str, Decimal]
    ) -> Decimal:
        """
        Calculate total portfolio value.
        
        Args:
            current_prices: Current market prices
            
        Returns:
            Total portfolio value
        """
        ...

    @abstractmethod
    def get_buying_power(self) -> Decimal:
        """
        Get available buying power.
        
        Returns:
            Available buying power for new positions
        """
        ...

    @abstractmethod
    def get_margin_requirements(
        self,
        symbol: str,
        quantity: Decimal
    ) -> Decimal:
        """
        Calculate margin requirements for position.
        
        Args:
            symbol: Symbol for position
            quantity: Position quantity
            
        Returns:
            Required margin amount
        """
        ...

    @abstractmethod
    def get_portfolio_snapshot(self) -> Portfolio:
        """
        Get current portfolio state snapshot.
        
        Returns:
            Complete portfolio state
        """
        ...


class PerformanceTracker(Protocol):
    """
    Interface for strategy performance tracking and analysis.
    
    Calculates and maintains performance metrics throughout
    strategy execution for analysis and reporting.
    """

    @abstractmethod
    def record_portfolio_value(
        self,
        timestamp: datetime,
        portfolio_value: Decimal
    ) -> None:
        """
        Record portfolio value at timestamp.
        
        Args:
            timestamp: Value timestamp
            portfolio_value: Total portfolio value
        """
        ...

    @abstractmethod
    def record_trade(
        self,
        symbol: str,
        fill: Fill
    ) -> None:
        """
        Record completed trade for analysis.
        
        Args:
            symbol: Traded symbol
            fill: Trade fill details
        """
        ...

    @abstractmethod
    def calculate_returns(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> Dict[str, Decimal]:
        """
        Calculate performance returns for period.
        
        Args:
            start_date: Period start
            end_date: Period end
            
        Returns:
            Dictionary with return metrics
        """
        ...

    @abstractmethod
    def calculate_risk_metrics(self) -> Dict[str, Decimal]:
        """
        Calculate risk-adjusted performance metrics.
        
        Returns:
            Dictionary with risk metrics (Sharpe, Sortino, etc.)
        """
        ...

    @abstractmethod
    def get_equity_curve(self) -> List[tuple[datetime, Decimal]]:
        """
        Get equity curve data points.
        
        Returns:
            List of (timestamp, portfolio_value) tuples
        """
        ...


# Exception Types
class StrategyError(Exception):
    """Base exception for strategy errors"""
    pass


class OrderError(StrategyError):
    """Exception for order-related errors"""
    pass


class PortfolioError(StrategyError):
    """Exception for portfolio management errors"""
    pass


class ValidationError(StrategyError):
    """Exception for validation errors"""
    pass


class InsufficientFundsError(PortfolioError):
    """Exception for insufficient buying power"""
    pass


class InvalidParametersError(StrategyError):
    """Exception for invalid strategy parameters"""
    pass
